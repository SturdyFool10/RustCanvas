//! Protocol Buffers implementation for binary messaging
//! This crate provides the message types and (de)serialization for our WebSocket protocol

// Generated protocol buffer code
// This includes the code generated by prost during the build process
#[allow(clippy::derive_partial_eq_without_eq)]
#[allow(clippy::all)]
#[allow(unused)]
pub mod proto {
    // Include the generated code that was copied to our source tree
    // This avoids issues with the OUT_DIR environment variable
    include!("generated/mod.rs");
}

// Re-export all types from the generated proto module
pub use proto::*;

// Module containing helpers for working with our protocol
pub mod helpers {
    use bytes::{Bytes, BytesMut};
    use prost::Message;

    /// Decode any protobuf message from raw bytes
    pub fn decode_message<T>(bytes: &[u8]) -> Result<T, prost::DecodeError>
    where
        T: Message + Default,
    {
        T::decode(bytes)
    }

    /// Encode any protobuf message to bytes
    pub fn encode_message<T>(message: &T) -> Bytes
    where
        T: Message,
    {
        let mut buf = BytesMut::with_capacity(message.encoded_len());
        message.encode(&mut buf).expect("Failed to encode message");
        buf.freeze()
    }

    /// Create a new message ID for use in messages
    pub fn new_message_id() -> u64 {
        use std::sync::atomic::{AtomicU64, Ordering};
        static NEXT_ID: AtomicU64 = AtomicU64::new(1);
        NEXT_ID.fetch_add(1, Ordering::Relaxed)
    }

    /// Get current timestamp in milliseconds
    pub fn current_timestamp() -> u64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }
}

/// Detects the message type from a binary blob using a protobuf descriptor file or bytes.
///
/// This function reads a compiled FileDescriptorSet from the given path,
/// builds a descriptor pool, and attempts to decode the provided blob
/// against each message type in the pool.
///
/// # Arguments
/// * `blob` - The binary data to decode
/// * `descriptor_bytes` - The bytes of the compiled protobuf descriptor set
///
/// # Returns
/// * `Some(String)` - The full name of the first message type that successfully decodes
/// * `None` - If no message types can decode the blob
///
/// # Example
/// ```no_run
/// use protocol::get_proto_type;
/// let descriptor_bytes = include_bytes!("descriptor_set.bin");
/// let blob = b"\x08\x96\x01\x12\x04test";
/// if let Some(message_type) = get_proto_type(blob, descriptor_bytes) {
///     println!("Detected message type: {}", message_type);
/// }
/// ```
pub fn get_proto_type(blob: &[u8], descriptor_bytes: &[u8]) -> Option<String> {
    use prost::Message;
    use prost_reflect::bytes::Bytes;
    use prost_reflect::{DescriptorPool, DynamicMessage};
    use prost_types::FileDescriptorSet;

    let file_descriptor_set = FileDescriptorSet::decode(descriptor_bytes).ok()?;
    let pool = DescriptorPool::from_file_descriptor_set(file_descriptor_set).ok()?;

    for descriptor in pool.all_messages() {
        let full_name = descriptor.full_name().to_string();
        if DynamicMessage::decode(descriptor, Bytes::from(blob.to_vec())).is_ok() {
            return Some(full_name);
        }
    }
    None
}

/// Legacy: Detects the message type from a binary blob using a protobuf descriptor file path.
/// This is kept for compatibility, but prefer `get_proto_type` for new code.
pub fn detect_message_type(
    blob: &[u8],
    descriptor_path: &std::path::Path,
) -> Result<String, Box<dyn std::error::Error>> {
    use std::fs;
    let descriptor_bytes = fs::read(descriptor_path)?;
    get_proto_type(blob, &descriptor_bytes)
        .ok_or_else(|| "No message type could decode the provided blob".into())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper_functions() {
        // Test message ID generation
        let id1 = helpers::new_message_id();
        let id2 = helpers::new_message_id();
        assert_ne!(id1, id2);
        assert!(id1 > 0);
        assert!(id2 > 0);

        // Test timestamp generation
        let timestamp = helpers::current_timestamp();
        assert!(timestamp > 0);
    }

    #[test]
    fn test_encode_decode_with_placeholder() {
        // This test uses the placeholder message type
        // In a real scenario, this would use your actual proto-defined messages
        use proto::TestMessage as PlaceholderMessage;

        let original = PlaceholderMessage {
            message: "Test message".to_string(),
        };

        // Encode
        let bytes = helpers::encode_message(&original);

        // Decode
        let decoded: PlaceholderMessage = helpers::decode_message(&bytes).unwrap();

        // Compare
        assert_eq!(original.message, decoded.message);
    }

    #[test]
    fn test_detect_message_type_function_exists() {
        // This test verifies that the detect_message_type function compiles
        // In a real test, you would need a valid descriptor file and blob
        use std::path::Path;

        let result = super::detect_message_type(b"invalid_blob", Path::new("nonexistent.desc"));
        // The function should return an error for invalid input
        assert!(result.is_err());
    }

    #[test]
    fn test_get_proto_type_function_exists() {
        // This test verifies that get_proto_type function compiles and returns None for invalid input
        let descriptor_bytes = b"not_a_real_descriptor";
        let result = super::get_proto_type(b"invalid_blob", descriptor_bytes);
        assert!(result.is_none());
    }
}
