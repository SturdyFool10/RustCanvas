//! Protocol Buffers implementation for binary messaging
//! This crate provides the message types and (de)serialization for our WebSocket protocol

// Generated protocol buffer code
// This includes the code generated by prost during the build process
#[allow(clippy::derive_partial_eq_without_eq)]
#[allow(clippy::all)]
#[allow(unused)]
pub mod proto {
    // Include the generated code that was copied to our source tree
    // This avoids issues with the OUT_DIR environment variable
    include!("generated/mod.rs");
}

// Re-export all types from the generated proto module
pub use proto::*;

// Module containing helpers for working with our protocol
pub mod helpers {
    use bytes::{Bytes, BytesMut};
    use prost::Message;

    /// Decode any protobuf message from raw bytes
    pub fn decode_message<T>(bytes: &[u8]) -> Result<T, prost::DecodeError>
    where
        T: Message + Default,
    {
        T::decode(bytes)
    }

    /// Encode any protobuf message to bytes
    pub fn encode_message<T>(message: &T) -> Bytes
    where
        T: Message,
    {
        let mut buf = BytesMut::with_capacity(message.encoded_len());
        message.encode(&mut buf).expect("Failed to encode message");
        buf.freeze()
    }

    /// Create a new message ID for use in messages
    pub fn new_message_id() -> u64 {
        use std::sync::atomic::{AtomicU64, Ordering};
        static NEXT_ID: AtomicU64 = AtomicU64::new(1);
        NEXT_ID.fetch_add(1, Ordering::Relaxed)
    }

    /// Get current timestamp in milliseconds
    pub fn current_timestamp() -> u64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper_functions() {
        // Test message ID generation
        let id1 = helpers::new_message_id();
        let id2 = helpers::new_message_id();
        assert_ne!(id1, id2);
        assert!(id1 > 0);
        assert!(id2 > 0);

        // Test timestamp generation
        let timestamp = helpers::current_timestamp();
        assert!(timestamp > 0);
    }

    #[test]
    fn test_encode_decode_with_placeholder() {
        // This test uses the placeholder message type
        // In a real scenario, this would use your actual proto-defined messages
        use proto::TestMessage as PlaceholderMessage;

        let original = PlaceholderMessage {
            message: "Test message".to_string(),
        };

        // Encode
        let bytes = helpers::encode_message(&original);

        // Decode
        let decoded: PlaceholderMessage = helpers::decode_message(&bytes).unwrap();

        // Compare
        assert_eq!(original.message, decoded.message);
    }
}
